---
title: "Campbell_2017_SRR5164443_preliminary_seurat_analysis"
author: "Matthew Banton"
date: "09/11/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Re-analysis of mouse hypothalamic scRNAseq data from Campbell et. al., 2017

Source of data: Campbell, J.N., Macosko, E.Z., Fenselau, H., Pers, T.H., Lyubetskaya, A., Tenen, D., Goldman, M., Verstegen, A.M., Resch, J.M., McCarroll, S.A. and Rosen, E.D., 2017. A molecular census of arcuate hypothalamus and median eminence cell types. Nature neuroscience, 20(3), p.484.

* <https://www.ncbi.nlm.nih.gov/pubmed/28166221>

* <https://www.nature.com/articles/nn.4495>

## Load packages and set working directory

```{r}

library(tidyverse)
library(scater)
library(dplyr)
library(limma)
library(SingleCellExperiment)
library(Seurat)
library(mclust)
library(Matrix)
library(tibble)

setwd("/media/data/mattb/projects/Brian_scRNAseq_website/R_projects/mouse_hypothalamus_scRNAseq")

```

## Import expression matrix

An expression matrix for each mouse replicate from the Campbell paper was created using zUMIs.

Descrive zUMIs here and give a link:....

### Import SRR5164443 into seurat

SRR5164443 is the smallest dataset so the seurat scRNAseq analysis will be perofmed on this mouse replicate first. SRR5164443 is a CHOW fed mouse (replicate 4 of 5) that was processed on day 6.


```{r}

# Load zUMI data and assign a variable name
campbell_zUMIs_object<- readRDS("/media/data/mattb/projects/Brian_scRNAseq_website/data/campbell/SRR5164443/zUMIs_output/expression/SRR5164443_default_STAR.dgecounts.rds")

campbell_expression_matrix<-  as.matrix(campbell_zUMIs_object$umicount$exon$all)

dim(campbell_expression_matrix)
# 4851 cells detected and 23543 genes.

campbell_expression_matrix[1:5,1:5]

# Summary of total expression per cell:
summary(colSums(campbell_expression_matrix))

# write.csv(campbell_expression_matrix,"campbell_SRR5164443_expression_matrix.csv", quote=F)

## Manually check the number of genes detected in three or more cells
# a lot of genes are not detected in 3 or more cells
tmp <- apply(campbell_expression_matrix, 1, function(x) sum(x>0))
table(tmp>=3)
 
# FALSE  TRUE 
#  5354 18189
 
keep <- tmp>=3
tmp <- campbell_expression_matrix[keep,]
at_least_one <- apply(tmp, 2, function(x) sum(x>0))
summary(at_least_one)
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#      1     195     261     390     423    5761 
  
## Cells have between 1 and 5761 genes expressed. Median is 261 genes per cell. Very few!!
## Campbell paper used minimum of 800 genes per cell!

dim(tmp)
# [1] 18189  4851

## Hitogram of how many genes per cell and number of counts per cell: 
at_least_one <- apply(campbell_expression_matrix, 2, function(x) sum(x>0))
par(mfrow=c(1,2)) # One row and two columns
hist(at_least_one, breaks = 100,
     main = "Distribution of detected genes",
     xlab = "Genes with at least one tag")
abline(v= 800, col = "red") 

hist(colSums(campbell_expression_matrix),
     breaks = 100, main = "Expression sum per cell",
     xlab = "Sum expression")

## Create a Seurat object to contain scRNA seq data:
seurat_campbell <- CreateSeuratObject(raw.data = campbell_expression_matrix, 
                                 min.cells = 3, 
                                 min.genes = 800, 
                                 project = "CAMPBELL")

# How many cells and genes passed through initial filtering:
seurat_campbell
# 17816 genes across 3515 samples (for 200 genes per cell)
# 14861 genes across 401 samples (for 800 genes per cell)

class(seurat_campbell)
seurat_campbell@data[1:5,1:5]
dim(seurat_campbell@data)

slotNames(seurat_campbell)
```

## QC cells


```{r}
## Import list of mouse mitocondrially encoded genes:

mito_genes_table<- read.csv("mito_genes_table.csv", header = TRUE)
head(mito_genes_table)

## Make list of mitocondrial gene IDS:
mito_genes <- mito_genes_table$id_with_url
mito_genes
length(mito_genes)

## Identify which mitochondrially expressed gene IDs are present in my dataset:
test<-seurat_campbell@raw.data[mito_genes, ]
test
dim(test)
rownames(test)
mito_genes

!grepl("NA", rownames(test))
mito_genes_present<- mito_genes[!grepl("NA", rownames(test))]
mito_genes_present
seurat_campbell@raw.data[mito_genes_present, 1:5]
dim(seurat_campbell@raw.data[mito_genes_present, ])

## Calculate the percentage of mitcondrial gene counts per cell
percent_mito <- Matrix::colSums(seurat_campbell@raw.data[mito_genes_present, ])/Matrix::colSums(seurat_campbell@raw.data)
percent_mito
summary(percent_mito)
class(percent_mito)
rownames(percent_mito)

# Investigate the meta data
head(seurat_campbell@meta.data)

# add percentage mitocondrial genes into metadata
seurat_campbell <- AddMetaData(object = seurat_campbell,
                    metadata = percent_mito,
                    col.name = "percent_mito")


#add mouse replicate into  metadata


experiment_name<- rep("SRR5164443", length(percent_mito))
names(experiment_name)<- names(percent_mito)

seurat_campbell <- AddMetaData(object = seurat_campbell,
                    metadata = experiment_name,
                    col.name = "experiment")

# Investigate the meta data
head(seurat_campbell@meta.data)

# plot number of genes, UMIs, and % mitochondria
VlnPlot(object = seurat_campbell,
        features.plot = c("nGene", "nUMI", "percent_mito"),
        nCol = 3)


# GenePlot is typically used to visualize gene-gene relationships, but can
# be used for anything calculated by the object, i.e. columns in
# object@meta.data, PC scores etc.  Since there is a rare subset of cells
# with an outlier level of high mitochondrial percentage and also low UMI
# content, we filter these as well
par(mfrow = c(1, 2))
GenePlot(object = seurat_campbell, gene1 = "nUMI", gene2 = "percent_mito")
GenePlot(object = seurat_campbell, gene1 = "nUMI", gene2 = "nGene")

```

## Filter cells


```{r}

# manual check; I already know all cells have >200 genes
table(seurat_campbell@meta.data$percent_mito < 0.005 & seurat_campbell@meta.data$nGene<5000)
 

# FALSE  TRUE 
#   16   385 
 
# perform the filtering using FilterCells()
seurat_campbell <- FilterCells(object = seurat_campbell,
                    subset.names = c("nGene", "percent_mito"),
                    low.thresholds = c(800, -Inf),
                    high.thresholds = c(5000, 0.005))
 
# 62 cells are filtered out; numbers consistent with above
seurat_campbell
# An object of class seurat in project CAMPBELL 
# 14861 genes across 385 samples.
 
 
```

## Normalising data



After removing unwanted cells from the dataset, the next step is to normalize the data. By default, we employ a global-scaling normalization method “LogNormalize” that normalizes the gene expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result.

```{r}

## Plot graph of total expression before normalisation

hist(colSums(seurat_campbell@data),
     breaks = 100,
     main = "Total expression before normalisation",
     xlab = "Sum of expression")

seurat_campbell <- NormalizeData(object = seurat_campbell, normalization.method = "LogNormalize", 
    scale.factor = 1e4)

hist(colSums(seurat_campbell@data),
     breaks = 100,
     main = "Total expression after normalisation",
     xlab = "Sum of expression")

```

## Find variable genes between cells for use in PC analysis later


```{r}
# the variable genes slot is empty before the analysis
seurat_campbell@var.genes

 
# Find the variable genes using FindVariableGenes function (it is recommended to play with these setting to find the best results:)
?FindVariableGenes
seurat_campbell <- FindVariableGenes(object = seurat_campbell,
                          mean.function = ExpMean,
                          dispersion.function = LogVMR,
                          x.low.cutoff = 0.0125,
                          x.high.cutoff = 3,
                          y.cutoff = 0.5)

seurat_campbell <- FindVariableGenes(object = seurat_campbell,
                          mean.function = ExpMean,
                          dispersion.function = LogVMR,
                          x.low.cutoff = 0.0125,
                          x.high.cutoff = 3,
                          y.cutoff = 0.5,
                          num.bin = 20,
                          binning.method = "equal_width"
                          )

seurat_campbell <- FindVariableGenes(object = seurat_campbell,
                          mean.function = ExpMean,
                          dispersion.function = LogVMR,
                          x.low.cutoff = 0.0125,
                          x.high.cutoff = 4,
                          y.cutoff = 0.5,
                          num.bin = 20,
                          binning.method = "equal_width"
                          )


seurat_campbell <- FindVariableGenes(object = seurat_campbell,
                          mean.function = ExpMean,
                          dispersion.function = LogVMR,
                          x.low.cutoff = 0.05,
                          x.high.cutoff = 4,
                          y.cutoff = 0.5,
                          num.bin = 20,
                          binning.method = "equal_width"
                          )
length(seurat_campbell@var.genes)

seurat_campbell <- FindVariableGenes(object = seurat_campbell,
                          mean.function = ExpMean,
                          dispersion.function = LogVMR,
                          x.low.cutoff = 0.05,
                          x.high.cutoff = 4,
                          y.cutoff = 0.5,
                          num.bin = 20,
                          binning.method = "equal_frequency"
                          )
length(seurat_campbell@var.genes)

seurat_campbell <- FindVariableGenes(object = seurat_campbell,
                          mean.function = ExpMean,
                          dispersion.function = LogVMR,
                          x.low.cutoff = 0.05,
                          x.high.cutoff = 4,
                          y.cutoff = 0.5,
                          num.bin = 40,
                          binning.method = "equal_width"
                          )
length(seurat_campbell@var.genes)


seurat_campbell <- FindVariableGenes(object = seurat_campbell,
                          mean.function = ExpMean,
                          dispersion.function = LogVMR,
                          x.low.cutoff = 0.05,
                          x.high.cutoff = 4,
                          y.cutoff = 0.5,
                          num.bin = 50,
                          binning.method = "equal_width"
                          )
length(seurat_campbell@var.genes)

seurat_campbell <- FindVariableGenes(object = seurat_campbell,
                          mean.function = ExpMean,
                          dispersion.function = LogVMR,
                          x.low.cutoff = 0.05,
                          x.high.cutoff = 4,
                          y.cutoff = 0.5,
                          num.bin = 40,
                          binning.method = "equal_frequency"
                          )
length(seurat_campbell@var.genes)

seurat_campbell <- FindVariableGenes(object = seurat_campbell,
                          mean.function = ExpMean,
                          dispersion.function = LogVMR,
                          x.low.cutoff = 0.05,
                          x.high.cutoff = 4,
                          y.cutoff = 1,
                          num.bin = 40,
                          binning.method = "equal_width"
                          )
length(seurat_campbell@var.genes)


seurat_campbell <- FindVariableGenes(object = seurat_campbell,
                          mean.function = ExpMean,
                          dispersion.function = LogVMR,
                          x.low.cutoff = 0.1,
                          x.high.cutoff = 4,
                          y.cutoff = 0.5,
                          num.bin = 50,
                          binning.method = "equal_width"
                          )
length(seurat_campbell@var.genes)


seurat_campbell <- FindVariableGenes(object = seurat_campbell,
                          mean.function = ExpMean,
                          dispersion.function = LogVMR,
                          x.low.cutoff = 0.05,
                          x.high.cutoff = 4,
                          y.cutoff = 0.5,
                          num.bin = 40,
                          binning.method = "equal_width"
                          )
length(seurat_campbell@var.genes)




# vector of variable genes
head(seurat_campbell@var.genes)
seurat_campbell@data["ENSMUSG00000000058",]
 
# number of variable genes
length(seurat_campbell@var.genes)

 
# mean and variance of genes are stored pbmc@hvg.info
head(seurat_campbell@hvg.info)

seurat_campbell@data["ENSMUSG00000022548",]
```
## Scaling the data and removing unwanted sources of variation

```{r}
## slot is empty before running ScaleData()
seurat_campbell@scale.data

## build linear model using nUMI and percent_mito
## May need to do this for difference mouse replicates.
seurat_campbell <- ScaleData(object = seurat_campbell, vars.to.regress = c("nUMI", "percent_mito"))

class(seurat_campbell@scale.data)

```




## Perform PC analysis for dimensional reduction for use in clustering later

Next we perform PCA on the scaled data. By default, the genes in object@var.genes are used as input, but can be defined using pc.genes. We have typically found that running dimensionality reduction on highly variable genes can improve performance. However, with UMI data - particularly after regressing out technical variables, we often see that PCA returns similar (albeit slower) results when run on much larger subsets of genes, including the whole transcriptome.

```{r}


seurat_campbell <- RunPCA(object = seurat_campbell,
               pc.genes = seurat_campbell@var.genes,
               do.print = TRUE,
               pcs.print = 1:5,
               genes.print = 5)

PrintPCAParams(seurat_campbell)

# Following function not found. Replaces with the one above?
# GetCalcParam(object = seurat_campbell, calculation = "RunPCA", parameter = "pc.genes")
 
## Seurat provides several useful ways of visualizing both cells and genes that define the PCA, including PrintPCA, VizPCA, PCAPlot, and PCHeatmap

PrintPCA(object = seurat_campbell, pcs.print = 1:5, genes.print = 5, use.full = FALSE)
 
# visualise top genes associated with principal components
VizPCA(object = seurat_campbell, pcs.use = 1:4)

# The PCAPlot() function plots the principal components from a PCA; cells are coloured by their identity class according to seurat_campbell@ident.
PCAPlot(object = seurat_campbell, dim.1 = 1, dim.2 = 2)

# In particular PCHeatmap allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide which PCs to include for further downstream analyses. Both cells and genes are ordered according to their PCA scores. Setting cells.use to a number plots the ‘extreme’ cells on both ends of the spectrum, which dramatically speeds plotting for large datasets. Though clearly a supervised analysis, we find this to be a valuable tool for exploring correlated gene sets.
PCHeatmap(object = seurat_campbell, pc.use = 1, cells.use = 500, do.balanced = TRUE, label.columns = FALSE)
PCHeatmap(object = seurat_campbell, pc.use = 2, cells.use = 500, do.balanced = TRUE, label.columns = FALSE)
## Ignore warnings!

## Plotting multiple heatmaps
PCHeatmap(object = seurat_campbell,
          pc.use = 1:16,
          cells.use = 500,
          do.balanced = TRUE,
          label.columns = FALSE)


## However, the PCA was only performed on the most variable genes, which is a subset of the dataset. The ProjectPCA step scores each gene in the dataset based on their correlation with the calculated components. This is useful because there may be genes that were not detected as variable genes in the variable gene selection step, which are still strongly correlated with cellular heterogeneity.
# the results of the projected PCA can be explored by setting use.full=TRUE in the functions above
?ProjectPCA
seurat_campbell <- ProjectPCA(object = seurat_campbell, do.print = TRUE)

```




## Determine statistically significant principal components

To overcome the extensive technical noise in any single gene for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a ‘metagene’ that combines information across a correlated gene set. Determining how many PCs to include downstream is therefore an important step.

The next steps are to determine how many principal components to use in downstream analyses, which is an important step for Seurat. The tutorial goes through two methods: one uses a statistical test based on a random null model, which is time-consuming for large datasets due to the resampling and may not return a clear cutoff and the other is a commonly used heuristic. The statistical test is carried out by the JackStraw() function, which randomly permutes a subset of data, and calculates projected PCA scores for these “random” genes. Then compares the PCA scores for the “random” genes with the observed PCA scores to determine statistical significance. End result is a p-value for each gene’s association with each principal component. This resampling test was inspired by the jackstraw procedure. Significant principal components are those with a strong enrichment of low p-value genes.

```{r}
# NOTE: This process can take a long time for big datasets, comment out for expediency.
# More approximate techniques such as those implemented in PCElbowPlot() can be used to reduce computation time
?JackStraw
seurat_campbell <- JackStraw(object = seurat_campbell,
                  num.replicate = 100,
                  display.progress = TRUE
                  )

## The JackStrawPlot() function provides a visualisation tool for comparing the distribution of p-values for each principal component with a uniform distribution (dashed line). “Significant” principal components will show a strong enrichment of genes with low p-values (solid curve above the dashed line).
JackStrawPlot(object = seurat_campbell, PCs = 1:20)
## Maybe up to the 14th PC?

## A less computationally intensive heuristic method for finding the statistically significant PCAs is using an elbow plot 
PCElbowPlot(object = seurat_campbell)


```

### comment from the authours:
' We followed the jackStraw here, admittedly buoyed by seeing the PCHeatmap returning interpretable signals (including canonical dendritic cell markers) throughout these PCs. Though the results are only subtly affected by small shifts in this cutoff (you can test below), we strongly suggest always explore the PCs they choose to include downstream.'

Looks like I need to be very careful at choosing the right number of PCs for down stream analysis? Maybe try different values?!


## Cell clustering

The FindClusters() function implements the clustering procedure. The resolution parameter adjusts the granularity of the clustering with higher values leading to more clusters, i.e. higher granularity. According to the authors of Seurat, setting resolution between 0.6 – 1.2 typically returns good results for datasets with around 3,000 cells. The clusters are saved in the @ident slot of the Seurat object.

```{r}
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
?FindClusters
seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:14, 
    resolution = 0.6, print.output = 0, save.SNN = TRUE)
# if you get the error
# No Java runtime present, requesting install.
# you need to download and install the Java SE Development Kit
# http://www.oracle.com/technetwork/java/javase/downloads/index.html
 
# save.SNN = TRUE saves the SNN so that the clustering algorithm can be rerun using the same graph
# but with a different resolution value see ?FindClusters


## A useful feature in Seurat v2.0 is the ability to recall the parameters that were used in the latest function calls for commonly used functions. For FindClusters, we provide the function PrintFindClustersParams to print a nicely formatted formatted summary of the parameters that were chosen.
PrintFindClustersParams(object = seurat_campbell)

```





## Create t-SNE plot and overlay the clusters identified above on plot

Seurat continues to use tSNE as a powerful tool to visualize and explore these datasets. While we no longer advise clustering directly on tSNE components, cells within the graph-based clusters determined above should co-localize on the tSNE plot. This is because the tSNE aims to place cells with similar local neighborhoods in high-dimensional space together in low-dimensional space. As input to the tSNE, we suggest using the same PCs as input to the clustering analysis, although computing the tSNE based on scaled gene expression is also supported using the genes.use argument.


```{r}
?RunTSNE
seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:14, do.fast = TRUE)

# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = seurat_campbell)
```





## Optimise the clustering and visualise using t-SNE

```{r}
############### dims.use = 1:14 resolution = 0.6

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:14, 
    resolution = 0.6, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:14, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 3 clusters

############### dims.use = 1:14 resolution = 1.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:14, 
    resolution = 1.0, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:14, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 5 clusters

############### dims.use = 1:14 resolution = 1.5

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:14, 
    resolution = 1.5, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:14, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 5 clusters

############### dims.use = 1:14 resolution = 2.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:14, 
    resolution = 2.0, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:14, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 7 clusters







############### dims.use = 1:16 resolution = 0.6

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:16, 
    resolution = 0.6, print.output = 0, save.SNN = TRUE, force.recalc = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:16, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 3 clusters

############### dims.use = 1:16 resolution = 1.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:16, 
    resolution = 1.0, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:16, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 4 clusters

############### dims.use = 1:16 resolution = 1.5

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:16, 
    resolution = 1.5, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:16, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 5 clusters

############### dims.use = 1:16 resolution = 1.6

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:16, 
    resolution = 1.6, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:16, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 6 clusters

############### dims.use = 1:16 resolution = 2.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:16, 
    resolution = 2.0, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:16, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 7 clusters









############### dims.use = 1:9 resolution = 0.6

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:9, 
    resolution = 0.6, print.output = 0, save.SNN = TRUE, force.recalc = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:9, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 3 clusters

############### dims.use = 1:9 resolution = 1.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:9, 
    resolution = 1.0, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:9, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 3 clusters

############### dims.use = 1:9 resolution = 1.5

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:9, 
    resolution = 1.5, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:9, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 6 clusters

############### dims.use = 1:9 resolution = 2.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:9, 
    resolution = 2.0, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:9, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 8 clusters





############### dims.use = 1:12 resolution = 0.6

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:12, 
    resolution = 0.6, print.output = 0, save.SNN = TRUE, force.recalc = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:12, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 3 clusters

############### dims.use = 1:12 resolution = 1.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:12, 
    resolution = 1.0, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:12, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 4 clusters

############### dims.use = 1:12 resolution = 1.5

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:12, 
    resolution = 1.5, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:12, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 6 clusters

############### dims.use = 1:12 resolution = 2.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:12, 
    resolution = 2.0, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:12, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 9 clusters






############### dims.use = 1:17 resolution = 0.6

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:17, 
    resolution = 0.6, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:17, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 4 clusters

############### dims.use = 1:17 resolution = 1.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:17, 
    resolution = 1.0, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:17, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 4 clusters

############### dims.use = 1:17 resolution = 1.5

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:17, 
    resolution = 1.5, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:17, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 5 clusters

############### dims.use = 1:17 resolution = 2.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:17, 
    resolution = 2.0, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:17, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 8 clusters


############### dims.use = 1:17 resolution = 3.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:17, 
    resolution = 3.0, print.output = 0, force.recalc = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:17, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 19 clusters


############### dims.use = 1:17 resolution = 1.8

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:17, 
    resolution = 1.8, print.output = 0, force.recalc = TRUE, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:17, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 7 clusters
levels(seurat_campbell@ident)

 
table(seurat_campbell@ident)


############### dims.use = 1:17 resolution = 1.6

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:17, 
    resolution = 1.7, print.output = 0, force.recalc = TRUE, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:17, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 6 clusters
levels(seurat_campbell@ident)

 
table(seurat_campbell@ident)
##
```


dims.use = 1:17 resolution = 1.5 or 1.7 might be best?


## How does reducing the number of genes for the PC analysis by increasing the minimum cut-off value affect the clustering?

```{r}

seurat_campbell <- FindVariableGenes(object = seurat_campbell,
                          mean.function = ExpMean,
                          dispersion.function = LogVMR,
                          x.low.cutoff = 0.05,
                          x.high.cutoff = 4,
                          y.cutoff = 1,
                          num.bin = 40,
                          binning.method = "equal_width"
                          )
length(seurat_campbell@var.genes)

## Normalise data
seurat_campbell <- ScaleData(object = seurat_campbell, vars.to.regress = c("nUMI", "percent_mito"))

## run PCA
seurat_campbell <- RunPCA(object = seurat_campbell,
               pc.genes = seurat_campbell@var.genes,
               do.print = TRUE,
               pcs.print = 1:5,
               genes.print = 5)

PrintPCAParams(seurat_campbell)
 
# visualise top genes associated with principal components
VizPCA(object = seurat_campbell, pcs.use = 1:4)

PCAPlot(object = seurat_campbell, dim.1 = 1, dim.2 = 2)

## Plotting multiple heatmaps
PCHeatmap(object = seurat_campbell,
          pc.use = 1:16,
          cells.use = 500,
          do.balanced = TRUE,
          label.columns = FALSE)

seurat_campbell <- ProjectPCA(object = seurat_campbell, do.print = TRUE)

## Find statistically significant PCAs

seurat_campbell <- JackStraw(object = seurat_campbell,
                  num.replicate = 100,
                  display.progress = TRUE
                  )

JackStrawPlot(object = seurat_campbell, PCs = 1:20)
## Maybe up to the 16th PC?

PCElbowPlot(object = seurat_campbell)
## Maybe up to the 11th or 17th PC?

################
## optimise clustering

############### dims.use = 1:11 resolution = 1.5

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:11, 
    resolution = 1.5, print.output = 0, save.SNN = TRUE, force.recalc = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:11, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 6 clusters

############### dims.use = 1:11 resolution = 2.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:11, 
    resolution = 2.0, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:11, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 10 clusters











############### dims.use = 1:17 resolution = 1.5

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:17, 
    resolution = 1.5, print.output = 0, save.SNN = TRUE, force.recalc = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:17, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 6 clusters

############### dims.use = 1:17 resolution = 2.0

seurat_campbell <- FindClusters(object = seurat_campbell, reduction.type = "pca", dims.use = 1:17, 
    resolution = 2.0, print.output = 0, save.SNN = TRUE)

PrintFindClustersParams(object = seurat_campbell)

seurat_campbell <- RunTSNE(object = seurat_campbell, dims.use = 1:17, do.fast = TRUE)

TSNEPlot(object = seurat_campbell)

## 9 clusters



```

I think using more genes (original) analysis looks best as does including more PC dimensions in the FindClustersParams function. dims.use = 1:17 resolution = 1.8 might be best??


## Save object so it can be imported easily in the future.

```{r}

#saveRDS(seurat_campbell, file = "./seurat_campbell.rds")


```



## Finding differentially expressed genes (cluster biomarkers)

Seurat can help you find markers that define clusters via differential expression. By default, it identifes positive and negative markers of a single cluster (specified in ident.1), compared to all other cells. FindAllMarkers automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.

The min.pct argument requires a gene to be detected at a minimum percentage in either of the two groups of cells, and the thresh.test argument requires a gene to be differentially expressed (on average) by some amount between the two groups. You can set both of these to 0, but with a dramatic increase in time - since this will test a large number of genes that are unlikely to be highly discriminatory. As another option to speed up these computations, max.cells.per.ident can be set. This will downsample each identity class to have no more cells than whatever this is set to. While there is generally going to be a loss in power, the speed increases can be significiant and the most highly differentially expressed genes will likely still rise to the top.

```{r}

# find all markers of cluster 3
cluster3_markers <- FindMarkers(object = seurat_campbell, ident.1 = 3, min.pct = 0.2)
print(x = head(x = cluster3_markers, n = 5))


# find all markers distinguishing cluster 1 from clusters 0 and 4
cluster5_markers <- FindMarkers(object = seurat_campbell, ident.1 = 1, ident.2 = c(0, 4), 
    min.pct = 0.2)
print(x = head(x = cluster5_markers, n = 5))

# find markers for every cluster compared to all remaining cells, report
# Positive and negative ones.
?FindAllMarkers
seurat_campbell_markers <- FindAllMarkers(object = seurat_campbell, only.pos = FALSE, min.pct = 0.2)
top10_seurat_campbell_markers<- seurat_campbell_markers %>% group_by(cluster) %>% top_n(10, avg_logFC)
top10_seurat_campbell_markers
# write.csv(as.data.frame(top10_seurat_campbell_markers), file = "top10_seurat_campbell_markers", quote = FALSE)


# Seurat has several tests for differential expression which can be set with the test.use parameter (see our DE vignette for details). For example, the ROC test returns the ‘classification power’ for any individual marker (ranging from 0 - random, to 1 - perfect).
cluster1_markers_ROC <- FindMarkers(object = seurat_campbell, ident.1 = 1, thresh.use = 0.2, 
    test.use = "roc")
cluster1_markers_ROC

seurat_campbell_markers_ROC <- FindAllMarkers(object = seurat_campbell, only.pos = FALSE, min.pct = 0.2, test.use = "roc")
top10_seurat_campbell_markers_ROC<- seurat_campbell_markers_ROC %>% group_by(cluster) %>% top_n(10, avg_logFC)
top10_seurat_campbell_markers_ROC
write.csv(as.data.frame(top10_seurat_campbell_markers_ROC), file = "top10_seurat_campbell_markers_ROC", quote = FALSE)


#### Comapre DE methods:

levels(seurat_campbell@ident)

 
table(seurat_campbell@ident)
 
# 0  1  2  3  4  5  6 
# 74 73 72 68 50 46  2 
 
my_bimod <- FindMarkers(object = seurat_campbell,
                        ident.1 = 0,
                        thresh.use = 0.2,
                        test.use = "bimod",
                        only.pos = TRUE)
 
my_roc <- FindMarkers(object = seurat_campbell,
                      ident.1 = 0,
                      thresh.use = 0.2,
                      test.use = "roc",
                      only.pos = TRUE)
 
my_t <- FindMarkers(object = seurat_campbell,
                    ident.1 = 0,
                    thresh.use = 0.2,
                    test.use = "t",
                    only.pos = TRUE)
 
# Takes a very long time:
my_tobit <- FindMarkers(object = seurat_campbell,
                        ident.1 = 0,
                        thresh.use = 0.2,
                        test.use = "tobit",
                        only.pos = TRUE)
 
# my_mast <- FindMarkers(object = seurat_campbell,
#                         ident.1 = 0,
#                         thresh.use = 0.2,
#                         test.use = "MAST",
#                         only.pos = TRUE)
# 
# my_deseq2 <- FindMarkers(object = seurat_campbell,
#                         ident.1 = 0,
#                         thresh.use = 0.2,
#                         test.use = "DESeq2",
#                         only.pos = TRUE)

# identical set of genes
dim(my_bimod)
# [1] 732   5
dim(my_roc)
# [1] 732   7
dim(my_t)
# 1] 732   5
dim(my_tobit)
# [1] 732   5
 
# the rankings of the genes are quite similar between the methods
my_gene <- row.names(my_bimod)
a <- 1:length(my_gene)
b <- match(my_gene, row.names(my_roc))
c <- match(my_gene, row.names(my_t))
d <- match(my_gene, row.names(my_tobit))
 
# bimod vs. bimod
cor(a, a, method = "spearman")
# [1] 1
 
# bimod vs. roc
cor(a, b, method = "spearman")
# 0.6564564
 
# bimod vs. t
cor(a, c, method = "spearman")
# 0.6540798
 
# bimod vs. tobit
cor(a, d, method = "spearman")
# 0.6849513
 
par(mfrow=c(2,2))
barplot(a, main = 'bimod')
barplot(b, main = 'roc')
barplot(c, main = 't')
barplot(d, main = 'tobit')


```


## Visualise cluster marker genes:

We include several tools for visualizing marker expression. VlnPlot (shows expression probability distributions across clusters), and FeaturePlot (visualizes gene expression on a tSNE or PCA plot) are our most commonly used visualizations. We also suggest exploring RidgePlot, CellPlot, and DotPlot as additional methods to view your dataset.

```{r}
## shows expression probability distributions across clusters)
VlnPlot(object = seurat_campbell, features.plot = c("ENSMUSG00000029819", "ENSMUSG00000005705"))

# you can plot raw UMI counts as well
VlnPlot(object = seurat_campbell, features.plot = c("ENSMUSG00000029819", "ENSMUSG00000005705"), use.raw = TRUE, y.log = TRUE)

FeaturePlot(object = seurat_campbell, features.plot = c("ENSMUSG00000029819", "ENSMUSG00000005705", "ENSMUSG00000021685", "ENSMUSG00000051159"), cols.use = c("grey", "blue"), 
    reduction.use = "tsne")

## DoHeatmap generates an expression heatmap for given cells and genes. In this case, we are plotting the top 10 markers (or all markers if less than 10) for each cluster.

top10 <- seurat_campbell_markers %>% group_by(cluster) %>% top_n(10, avg_logFC)
# setting slim.col.label to TRUE will print just the cluster IDS instead of
# every cell name
DoHeatmap(object = seurat_campbell, genes.use = top10$gene, slim.col.label = TRUE, remove.key = TRUE)


```




## Assigning cell type identity to clusters

```{r}
# current.cluster.ids <- c(0, 1, 2, 3, 4, 5, 6, 7)
# new.cluster.ids <- c("CD4 T cells", "CD14+ Monocytes", "B cells", "CD8 T cells", 
#     "FCGR3A+ Monocytes", "NK cells", "Dendritic cells", "Megakaryocytes")
# pbmc@ident <- plyr::mapvalues(x = pbmc@ident, from = current.cluster.ids, to = new.cluster.ids)
# TSNEPlot(object = pbmc, do.label = TRUE, pt.size = 0.5)
# 
# 
# ## Save old cluster IDs when a new ID is added:
# 
# 
# # First lets stash our identities for later
# pbmc <- StashIdent(object = pbmc, save.name = "ClusterNames_0.6")
# 
# # Note that if you set save.snn=T above, you don't need to recalculate the
# # SNN, and can simply put: pbmc <- FindClusters(pbmc,resolution = 0.8)
# pbmc <- FindClusters(object = pbmc, reduction.type = "pca", dims.use = 1:10, 
#     resolution = 0.8, print.output = FALSE)
# 
# # Demonstration of how to plot two tSNE plots side by side, and how to color
# # points based on different criteria
# plot1 <- TSNEPlot(object = pbmc, do.return = TRUE, no.legend = TRUE, do.label = TRUE)
# plot2 <- TSNEPlot(object = pbmc, do.return = TRUE, group.by = "ClusterNames_0.6", 
#     no.legend = TRUE, do.label = TRUE)
# plot_grid(plot1, plot2)
# 
# # Find discriminating markers
# tcell.markers <- FindMarkers(object = pbmc, ident.1 = 0, ident.2 = 1)
# 
# # Most of the markers tend to be expressed in C1 (i.e. S100A4). However, we
# # can see that CCR7 is upregulated in C0, strongly indicating that we can
# # differentiate memory from naive CD4 cells.  cols.use demarcates the color
# # palette from low to high expression
# FeaturePlot(object = pbmc, features.plot = c("S100A4", "CCR7"), cols.use = c("green", 
#     "blue"))
# 
# pbmc <- SetAllIdent(object = pbmc, id = "ClusterNames_0.6")
# saveRDS(pbmc, file = "~/Projects/datasets/pbmc3k_final.rds")
```






## Title

```{r}


```











